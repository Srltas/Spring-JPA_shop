# Spring-JPA_shop
김영한님의 스프링 부트와 JPA 활용 1 - 웹 애플르케이션 개발 강의 학습 내용 정리 및 기록

## 22.06.05
* 도메인 분석 설계
  - 각 테이블의 연관관계 매핑 파악
* 엔티티 클래스 개발
  - 엔티티에는 가급적 Setter를 사용하지 않음
  - 변경 포인트가 너무 많아서, 유지보수가 어려워짐
  - 모든 연관관계는 지연로딩(LAZY)으로 설정함
  - 하이버네이트는 엔티티를 영속화 할 때, 컬렉션을 감싸서 하이버네이트가 제공하는 내장 컬렉션으로 변경 -> 컬렉션은 필드에서 바로 초기화 하는 것이 안전함
* 회원 리포지토리, 서비스 개발
  - 스프링 필드 주입 대신에 생성자 주입 사용 권장
* 회원 기능 테스트
  - @Transactional을 사용하면 테스트 케이스에서 롤백이 적용됨

## 22.06.06
* 상품, 주문 리포지토리, 서비스 개발
  - 비즈니스 로직 대부분이 엔티티에 있는 도메인 모델 패턴 학습
  - JPA 준영속 엔티티, 변경 감지 기능(dirty checking), 병합(merge) 학습
* 컨트롤러 개발
  - 엔티티는 핵심 비즈니스 로직만 가지고 있고, 화면을 위한 로직은 없어야 함
  - 폼 객체(or DTO)를 만들어 컨트롤러에서만 사용
  - Setter는 최대한 사용하지 않고 정적 팩토리를 사용해야 하는 이유 학습

# Spring-JPA_shop
김영한님의 스프링 부트와 JPA 활용 2 - API 개발과 성능 최적화

## 22.06.08
* 회원 등록 시 API 요청 스펙에 맞추어 별도의 DTO를 파마리터로 받도록 설계
* 회원 수정 시 PUT은 전체 업데이트 PATCH, POST는 부분 업데이트로 사용하는 것이 REST 스타일에 맞음
* 회원 조회 시 응답값으로 엔티티를 외부에 노출하지 않게 별도의 DTO를 만들어 반환하도록 설계

## 22.06.09
* 학습한 코드를 기반으로 ManyToOne, OneToOne 관계 최적화
* 엔티티를 직접 노출해서 조회를 할 때 양방향 연관관계가 걸린 곳은 꼭 @JsonIgnore 처리를 해야 양쪽이 서로를 호출하면서 무한 루프에 안 빠짐
* DTO로 사용했을 때 최악의 경우(모두 영속성 컨텍스트에 없을 시) 쿼리가 총 1 + N + N번 실행됨 ex) order 조회 1번(조회 결과 수가 N) + order -> member 조회 N번 + order -> delivery 조회 N번
* 엔티티를 fetch join을 사용해 쿼리 1번 조회로 데이터를 모두 가져옴 (member, delivery 모두 값을 가지고 있기 때문에 지연로딩X)
* 일반적인 SQL을 사용할 때 처럼 원하는 값을 선택하여 DTO를 통해 바로 조회를 할 수 있음

## 22.06.11
* 일대다 관계(OneToMany) 조회, 최적화
* 페치 조인으로 SQL 1번만 실행, distinct를 사용해 1대다 조인으로 증가한 row의 중복을 걸러줌 / 페이징 불가능
* ToOne(OneToOne, ManyToOne) 관계는 모두 페치조인, 컬렉션은 지연 로딩으로 조회
* 지연 로딩의 성능 최적화를 위해 hibernate.default_batch_fetch_size 적용
* OSIV : API 응답이 끝날 때 까지 영속성 컨텍스트와 데이터베이스 커넥션을 유지 -> controller에서 클라이언트에게 응답을 줄 때 까지 데이터베이스 커넥션을 유지하는 것
* 기본적으로 OSIV는 켜져있음
* OSIV를 끄면 모든 지연로딩을 트랜잭션 안에서(보통 @Trancational이 설정되어 있는 service 안에서) 다 처리해야 함
* 스프링 데이터 JPA를 통해 JpaRepository 인터페이스를 사용
* QueryDSL 설정 및 동적쿼리 사용
